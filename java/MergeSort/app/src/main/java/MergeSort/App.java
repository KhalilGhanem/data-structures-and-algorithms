/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package MergeSort;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        System.out.println(new App().getGreeting());
      System.out.println(5/2);
      int[] test={8,4,23,42,16,15};
//      int []test2=mergeSort(test);
//
//      for (int i : test2) {
//        System.out.println("M.. "+i);

//      }
      int []test2=QuickSort(test,0, test.length-1);

      for (int i : test2) {
        System.out.println("M.. "+i);
      }

    }
    public static int [] mergeSort(int[] arr){
    int n= arr.length;;
    if (n>1){
      int mid=n/2;
      int [] left=new int[mid];
      int [] right=new int[n-mid];

      for (int i = 0; i < mid; i++) {
        left[i] = arr[i];
      }
      for (int i = mid; i < n; i++) {
        right[i-mid] = arr[i];
      }
      mergeSort(left);
      mergeSort(right);
      merge(left,right,arr);
    }

    return arr;
  }

  public static void merge(int[]left,int[]right,int[] arr){
    int i=0, j=0, k=0;

    while (i < left.length && j < right.length){
      if (left[i] < right[j]){
        arr[k++] = left[i++];
      }else {
        arr[k++] = right[j++];
      }
    }

    while (i < left.length){
      arr[k++] = left[i++];
    }
    while (j < right.length){
      arr[k++] = right[j++];
    }

  }

//  ALGORITHM QuickSort(arr, left, right)
//    if left < right
//  // Partition the array by setting the position of the pivot value
//  DEFINE position <-- Partition(arr, left, right)
//  // Sort the left
//  QuickSort(arr, left, position - 1)
//  // Sort the right
//  QuickSort(arr, position + 1, right)
  // Code Challenge: Class 28
  public static  int[] QuickSort(int[] arr,int left, int right ){
      if (left<right){
        int position=Partition(arr, left, right);
        QuickSort(arr, left, position - 1);
        QuickSort(arr, position + 1, right);
      }
      return  arr;
  }

//  ALGORITHM Partition(arr, left, right)
//  // set a pivot value as a point of reference
//  DEFINE pivot <-- arr[right]
//  // create a variable to track the largest index of numbers lower than the defined pivot
//  DEFINE low <-- left - 1
//    for i <- left to right do
//    if arr[i] <= pivot
//  low++
//  Swap(arr, i, low)
//
//  // place the value of the pivot location in the middle.
//  // all numbers smaller than the pivot are on the left, larger on the right.
//  Swap(arr, right, low + 1)
//  // return the pivot index point
//     return low + 1

  public static int  Partition(int[] arr,int left, int right ){
      int pivot=arr[right];
      int low=left-1;
      for (int i=left;i<right;i++){
        if (arr[i]<=pivot){
          low++;
          Swap(arr,i,low);
        }
      }
    Swap(arr, right, low + 1);
    return  low+1;
  }

//  ALGORITHM Swap(arr, i, low)
//  DEFINE temp;
//  temp <-- arr[i]
//  arr[i] <-- arr[low]
//  arr[low] <-- temp
  public static void Swap(int[] arr,int i,int low){
      int temp=arr[i];
      arr[i]=arr[low];
      arr[low]=temp;
  }
}


